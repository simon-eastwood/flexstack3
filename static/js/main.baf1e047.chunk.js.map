{"version":3,"sources":["FlexModelUtils.ts","LoadTemplate.ts","App.tsx","index.tsx"],"names":["getConfig","tab","getType","TabNode","TYPE","Error","getId","max","dimension1","dimension2","result","Math","isNaN","setTabSetSize","tabset","updateIfNeeded","safeToSetWidth","minWidth","undefined","preferredWidth","width","getChildren","forEach","node","attrs","getMinWidth","currentWidth","getWidth","Object","keys","length","setSize","Actions","updateNodeAttributes","getModel","doAction","analyseRow","row","setWidth","tabsetChildren","filter","TabSetNode","getOrientation","Orientation","HORZ","ts","RowNode","childRowPreferredWidth","analyseRowTabs","nrOfHTabSets","console","log","VERT","childRowNrOfHTabSets","analyseModel","modelToAnalyse","alsoSetWidth","size","getRoot","tabs","model","nrOfHorizontalTabsets","removeTabset","maxPanelNr","maxPanel","panels","Map","panelNr","visitNodes","set","childrenToMove","child","tabToDestination","dest","mv","p","get","destMajor","moveNode","DockLocation","CENTER","destMinor","destPref","del","deleteTabset","reorderTabs","tabsToMove","panelPreferences","floor","abs","round","bundleExample","w2wTemplateLayout","global","layout","isEmpty","c","getComponent","loadTemplateModel","fullModel","initialModel","Array","template","Model","fromJson","push","bundle","bundleItem","mfeConfig","mfe","getMfeConfig","type","destinationPanel","newConfig","name","title","component","config","panel","getTemplate","adaptedModel","nrPanels","rms","deleteTab","action","rmEmptyTabs","App","useState","currentModel","_setCurrentModel","setCurrentModel","m","setOnAllowDrop","dragNode","dropInfo","location","BOTTOM","TOP","LEFT","RIGHT","disabled","className","onClick","a","addNode","addTabset","getParent","toJson","equaliseWidth","onAction","onModelChange","factory","dangerouslySetInnerHTML","__html","uri","style","height","overflow","src","border","scrolling","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.baf1e047.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\ninterface IConfig {\r\n    width: number | undefined,\r\n    minWidth: number | undefined,\r\n    panelPreferences: number[],\r\n    preferredWidth: number | undefined,\r\n    nrOfHTabsets:number | undefined\r\n}\r\n\r\n\r\n// typesafe access to avoid typos in code\r\nconst getConfig = (tab: FLNode): IConfig => {\r\n    if (tab.getType() === TabNode.TYPE) {\r\n        return (tab as TabSetNode).getConfig() as IConfig;\r\n    } else {\r\n        throw Error(`Node ${tab.getId()} is not a tab and so does not have config`)\r\n    }\r\n}\r\n\r\n// return the max, taking into account that either or both might be undefined\r\nconst max = (dimension1: number | undefined, dimension2: number | undefined): number | undefined => {\r\n    let result = Math.max(dimension1!, dimension2!);\r\n    if (isNaN(result)) {\r\n        if (dimension1) return dimension1;\r\n        if (dimension2) return dimension2;\r\n        return undefined\r\n    } else {\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\nconst setTabSetSize = (tabset: TabSetNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): IDimensions => {\r\n    const result: IDimensions = {\r\n        minWidth: undefined,\r\n        preferredWidth: undefined,\r\n        width: undefined\r\n    };\r\n\r\n    // iterate through the tabs to get sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const tab = node as TabNode;\r\n\r\n        result.minWidth = max(result.minWidth, getConfig(tab)?.minWidth);\r\n        result.width = max(result.width, getConfig(tab)?.width);\r\n        result.preferredWidth = max(result.preferredWidth, getConfig(tab)?.preferredWidth);\r\n    })\r\n\r\n    if (!result.preferredWidth) {\r\n        if (result.width) {\r\n            result.preferredWidth = result.width;\r\n        } else {\r\n            result.preferredWidth = result.minWidth;\r\n        }\r\n    }\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if (updateIfNeeded) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n        type Attrs = {\r\n            minWidth?: number,\r\n            width?: number\r\n        };\r\n        const attrs: Attrs = {};\r\n        if (result.minWidth && result.minWidth > 0 && tabset.getMinWidth() !== result.minWidth) {\r\n            attrs.minWidth = result.minWidth;\r\n        }\r\n        const currentWidth = tabset.getWidth();\r\n        if (!safeToSetWidth && currentWidth) {\r\n            // Reset the width or there will be layout problems\r\n            attrs.width = 999999999;  // only way to clear an already-set width\r\n        } else if (!currentWidth && safeToSetWidth && result.width && currentWidth !== result.width) {\r\n            // if the current width is undefined (otherwise the user has set it and we'd better leave it alone)\r\n            // and it is safe to set the width (there are other tabsets to use free space)\r\n            // and there IS a width to set and its new\r\n            // only then: set the width\r\n            attrs.width = result.width;\r\n        }\r\n\r\n\r\n        // Now set the size information collated from the child tabs at the tabset level in the model\r\n        if (Object.keys(attrs).length > 0) {\r\n            const setSize = Actions.updateNodeAttributes(tabset.getId(), attrs);\r\n            tabset.getModel().doAction(setSize);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// returns preferred width (defaulting to the min width if there is no prefferd) of all tabsets in the row\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): number => {\r\n    let preferredWidth = 0;\r\n    let setWidth = false;\r\n\r\n    const tabsetChildren = row.getChildren().filter((node) => node.getType() === TabSetNode.TYPE);\r\n    if (tabsetChildren.length >= 2 && updateIfNeeded && row.getOrientation() === Orientation.HORZ) {\r\n        setWidth = true; // can only do this if there enough tabsets\r\n    }\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = setTabSetSize(node as TabSetNode, updateIfNeeded, setWidth);\r\n\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += ts.preferredWidth ? ts.preferredWidth : ts.minWidth!;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, ts.preferredWidth ? ts.preferredWidth : ts.minWidth)!;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const childRowPreferredWidth = analyseRow(node as RowNode, updateIfNeeded, setWidth);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += childRowPreferredWidth;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, childRowPreferredWidth)!;\r\n            }\r\n        }\r\n    })\r\n\r\n    return preferredWidth;\r\n}\r\n\r\n\r\nconst analyseRowTabs = (row: RowNode): number => {\r\n    let nrOfHTabSets = 0;\r\n    console.log(\"analying row tabs\")\r\n    \r\n    // for a vertial row, the nr Of tabsets = max of child rows and 1\r\n    if (row.getOrientation() === Orientation.VERT) {\r\n        nrOfHTabSets = 1;\r\n    }\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                nrOfHTabSets++;\r\n            } \r\n        } else if (node.getType() === RowNode.TYPE ) {\r\n            // recurse for child row\r\n            const childRowNrOfHTabSets = analyseRowTabs(node as RowNode);\r\n            if (row.getOrientation() === Orientation.HORZ) {  \r\n                nrOfHTabSets += childRowNrOfHTabSets;\r\n            } else {\r\n                // I'm a vertical row, so take the max of chilren\r\n                console.log(\"Hit vertical row\")\r\n                nrOfHTabSets = max(nrOfHTabSets, childRowNrOfHTabSets)!;\r\n            }\r\n        }\r\n    })\r\n\r\n    return nrOfHTabSets;\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = true, alsoSetWidth: boolean = false): IAnalyzedModel => {\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(modelToAnalyse.getRoot(), updateIfNeeded, alsoSetWidth);\r\n\r\n    const tabs = analyseRowTabs (modelToAnalyse.getRoot());\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        preferredWidth: size,\r\n        nrOfHorizontalTabsets: tabs\r\n    }\r\n\r\n    console.log(result);\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\n\r\n\r\n// 1. find the tabsets within the model and put them into a map based on their panel number\r\n// 2. for each panel, if its panel nr is larger than max panel then it needs to be deleted but not before...\r\n// 3. ...moving its children to their preferred destination specified in panelPreferences.\r\n// The child nodes are then moved to their new preferred / available panel\r\nexport const removeTabset = (model: Model, maxPanelNr?: number): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n\r\n    // first find out how many tabsets there are in the model and collect them in a map. \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n    maxPanel = (maxPanelNr) ? maxPanelNr : panels.size;\r\n\r\n    if (panels.size < 2) {\r\n        // don't want to delete the last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    // Now delete the top N tabsets\r\n    // if this function is called without a maxPanelNr then that's just the last panel (e.g. 5)\r\n    // if this function is called with a maxPanelNr (cos we're loading a template and the user only wants e.g. 2 panels) then that could be more than 1\r\n\r\n    panels.forEach((ts, panelNr) => {\r\n        if (panelNr >= maxPanel) {\r\n            // move the children\r\n            const childrenToMove = new Map<TabNode, Destination>();\r\n            ts.getChildren().forEach((child) => {\r\n                if (child.getType() === 'tab') {\r\n                    const tab = child as TabNode;\r\n                    childrenToMove.set(tab, tabToDestination(tab, maxPanel - 1));\r\n                }\r\n            })\r\n\r\n            childrenToMove.forEach((dest, child) => {\r\n                let p = panels.get(dest.destMajor);\r\n                let mv;\r\n                if (p) {\r\n                    mv = Actions.moveNode(child.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                } else {\r\n                    // got to move it somewhere....then to root\r\n                    mv = Actions.moveNode(child.getId(), model.getRoot().getId(), DockLocation.CENTER, - 1, false);\r\n                }\r\n                model.doAction(mv);\r\n            })\r\n\r\n\r\n            // delete the tabset. Actually an empty tabset will not be rendered\r\n            // but this will confuse the task of finding next tab to remove\r\n            // so better to clean up\r\n            let del = Actions.deleteTabset(ts.getId());\r\n            model.doAction(del);\r\n        }\r\n    })\r\n\r\n    // With less tabsets, some other tabs might prefer to be moved\r\n    reorderTabs(model);\r\n    return model;\r\n}\r\n\r\n// move tabs if necessary so that they are all on their preferred panel, in the preferred order\r\nconst reorderTabs = (model: Model) => {\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n    // first find out how many tabsets there are in the model \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n\r\n    // Now iterate through the tabs and see where to move them\r\n    const tabsToMove = new Map<TabNode, Destination>();\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tab') {\r\n            tabsToMove.set(node as TabNode, tabToDestination(node as TabNode, panels.size));\r\n        }\r\n    });\r\n\r\n\r\n    // now do the moves\r\n    tabsToMove.forEach((dest, tab) => {\r\n        let mv;\r\n\r\n        if (dest.destMajor !== 0) {\r\n            let p = panels.get(dest.destMajor);\r\n            // tabOrder is the number after the decimal point\r\n            if (p) {\r\n                mv = Actions.moveNode(tab.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                model.doAction(mv);\r\n            }\r\n        }\r\n\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n// use tab config to see, for the given max panel, where the tab should go\r\ntype Destination = {\r\n    destPref: number | undefined, // the original config value (can be negative or undefined)\r\n    destMajor: number, // 0 means unknown destination\r\n    destMinor: number\r\n}\r\nconst tabToDestination = (tab: TabNode, maxPanel: number = 4): Destination => {\r\n    let destPref;\r\n\r\n    if (getConfig(tab)?.panelPreferences?.length >= maxPanel) {\r\n        destPref = getConfig(tab).panelPreferences[maxPanel - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n\r\n        return {\r\n            destPref,\r\n            destMajor,\r\n            destMinor\r\n        }\r\n    } else {\r\n        return {\r\n            destPref,\r\n            destMajor: 0,\r\n            destMinor: -1\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nexport const addTabset = (m: IAnalyzedModel) => {\r\n    console.log(\"ADDED\")\r\n\r\n     const a = Actions.addNode(  {type:\"tab\", component: \"pdf\", config:         {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"Nr 5\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n        }},  m.model.getRoot().getId(), DockLocation.RIGHT, 0, true)\r\n\r\n    m.model.doAction(a);\r\n    \r\n\r\n}\r\n\r\nexport const equaliseWidth = (m: IAnalyzedModel) => {\r\n    console.log(\"Equalise\");\r\n    type Attrs = {\r\n            weight?: number,\r\n            width?: number\r\n    };\r\n    const attrs: Attrs = {};\r\n    attrs.width = 999999999; // only way to clear an already-set width\r\n    attrs.weight = 1;\r\n  \r\n    console.log (\"Root orientation is\" + m.model.getRoot().getOrientation() )\r\n    m.model.visitNodes(node => {\r\n        if (node.getType() === TabSetNode.TYPE && node.getParent()!.getType() === RowNode.TYPE) {\r\n            const p = node.getParent()!;\r\n          \r\n            if (p.getType() === RowNode.TYPE) {\r\n                if (p.getOrientation() === Orientation.HORZ && p.getChildren().length > 1) {\r\n                              const setSize = Actions.updateNodeAttributes(node.getId(), attrs);\r\n                    m.model.doAction(setSize);\r\n                    console.log (\"Setting size of \" )\r\n                } else {\r\n                                    /* const setSize = Actions.updateNodeAttributes(node.getId(), attrs);\r\n                    m.model.doAction(setSize); */\r\n                    console.log(\"Not setting size of \" + node.getId()); console.log(p.getOrientation()); \r\n                    console.log (m.model.toJson())\r\n                }\r\n            }\r\n  \r\n        }\r\n    });\r\n\r\n}","import { Model, IJsonModel, TabSetNode, TabNode, Actions, Node as FLNode, Action } from 'flexlayout-react';\r\n\r\nimport { analyseModel, removeTabset } from './FlexModelUtils';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\nconst bundleExample = {\r\n    \"id\": \"igra\",\r\n    \"bundle\": [\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"Communication\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [1.1, 1.1, 1.1, 1.1, 1.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://ai.stanford.edu/~nilsson/MLBOOK.pdf#view=FitH\",\r\n            \"title\": \"Letter\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.3, -1.3, 2.1, 2.1, 2.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n            \"title\": \"Claims\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.4, -2.2, -3.2, 3.1, 3.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n            \"title\": \"Nr 4\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.2, -1.2, -1.2, -1.2, 4.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"Nr 5\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n        }\r\n\r\n    ]\r\n};\r\n\r\nconst w2wTemplateLayout: { name: string, model: IJsonModel } = {\r\n    name: 'w2w-template',\r\n    model: {\r\n        global: {\r\n            \"rootOrientationVertical\": false,\r\n            // \"tabSetEnableDivide\": false, // it keeps things simpler for moving tabs if all tabsets are labelled with a panel nr\r\n            // \"enableEdgeDock\": false, // otherwise the user can create new rows by dragging into the edge\r\n            //\"tabEnableClose\": false\r\n        }, // {tabSetEnableTabStrip:false}, // to have just splitters\r\n        layout: {\r\n            \"type\": \"row\",\r\n            \"children\": [\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"name\": \"\",\r\n                            \"type\": \"tab\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": true,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n};\r\n\r\n\r\nconst getMfeConfig = (mfe: string): IDimensions => {\r\n    // hard coded for now....\r\n\r\n    switch (mfe) {\r\n        case 'pdf':\r\n            return {\r\n                minWidth: 50,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n        case '123check':\r\n            return {\r\n                minWidth: 774,\r\n                preferredWidth: 1280,\r\n                width: 1280\r\n            }\r\n\r\n            break;\r\n        case 'image':\r\n            return {\r\n                minWidth: 250,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n\r\n            break;\r\n        default:\r\n            return {\r\n                minWidth: undefined,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n    }\r\n}\r\n\r\n\r\nconst isEmpty = (tab: TabNode): boolean => {\r\n    const c = tab.getComponent();\r\n    const check = !c || c.length === 0;\r\n    return check;\r\n}\r\n\r\n\r\nconst getTemplate = (): Model => {\r\n    const panels = new Array<TabNode>();\r\n\r\n    const template = Model.fromJson(w2wTemplateLayout.model);\r\n\r\n    template.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            const tab = node as TabNode;\r\n            if (isEmpty(tab)) {\r\n                panels.push(tab);\r\n            }\r\n        }\r\n    });\r\n\r\n    bundleExample.bundle.forEach((bundleItem) => {\r\n        const destPref = bundleItem.panelPreferences[panels.length - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n        const mfeConfig = getMfeConfig(bundleItem.type);\r\n\r\n        let destinationPanel = panels[0]; // default\r\n        if (destMajor <= panels.length) {\r\n            destinationPanel = panels[destMajor - 1];\r\n        }\r\n\r\n        const newConfig = { ...destinationPanel.getConfig(), ...mfeConfig, ...bundleItem };\r\n\r\n        const attrs = {\r\n            name: bundleItem.title,\r\n            component: bundleItem.type,\r\n            config: newConfig\r\n        };\r\n        const set = Actions.updateNodeAttributes(destinationPanel.getId(), attrs);\r\n        template.doAction(set);\r\n    });\r\n\r\n    panels.forEach(panel => console.log(panel));\r\n\r\n    return template;\r\n}\r\n\r\n\r\nconst rmEmptyTabs = (model: Model) => {\r\n    const rms = new Array<Action>();\r\n    console.log(\"deleting\");\r\n    model.visitNodes(node => {\r\n        if (node.getType() === TabNode.TYPE && isEmpty(node as TabNode)) {\r\n            rms.push(Actions.deleteTab(node.getId()))\r\n        }\r\n    });\r\n    rms.forEach(action => model.doAction(action));\r\n}\r\n\r\n// if maxPanel is undefined, return the canonical model (or in future the user's saved model if there is one, and the canonical model failing that)\r\n// if maxPanel is defined, transform the model \r\nexport const loadTemplateModel = (maxPanel?: number) => {\r\n    let initialModel = getTemplate();\r\n    let adaptedModel = initialModel;\r\n    let fullModel: IAnalyzedModel;\r\n    console.log (\"loading model\")\r\n\r\n    // if the caller has specified the nr of panels, then return a model that meets that requirement\r\n    if (maxPanel) {\r\n        adaptedModel = removeTabset(initialModel, maxPanel + 1);\r\n\r\n        fullModel = analyseModel(adaptedModel, true, true);\r\n\r\n    } else { // I have to figure out myself how many panels fit the current viewport\r\n        // HACK for demo DFR const availableWidth = window.innerWidth;\r\n        const availableWidth = 200;\r\n\r\n\r\n        fullModel = analyseModel(initialModel, true, true);\r\n        // see how many panels there are in the full model\r\n        let nrPanels = 0;\r\n        fullModel.model.visitNodes((node) => { if (node.getType() === TabSetNode.TYPE) nrPanels++ });\r\n\r\n        // remove tabset one by one until it fits\r\n        while (nrPanels > 1 && availableWidth < fullModel.preferredWidth) {\r\n            adaptedModel = removeTabset(fullModel.model, nrPanels);\r\n            fullModel = analyseModel(adaptedModel, true, true);\r\n            nrPanels--;\r\n        }\r\n\r\n    }\r\n\r\n    // Now that all the processing has finished,\r\n    // delete any empty tabsets in case some panels were not used by the bundle\r\n    rmEmptyTabs(fullModel.model);\r\n\r\n\r\n    // removing empty tabs will not impact the dimensions, so no need to recalculate\r\n    return fullModel;\r\n\r\n}","import React, { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport 'flexlayout-react/style/light.css'\r\n\r\nimport { Layout, Model, TabNode, Action, DockLocation, TabSetNode, RowNode, Orientation } from 'flexlayout-react';\r\n\r\nimport { addTabset, analyseModel, equaliseWidth } from './FlexModelUtils';\r\n\r\n\r\nimport { loadTemplateModel } from './LoadTemplate'\r\nimport { IAnalyzedModel } from './types';\r\n\r\nconst MAXTABSETS = 6;\r\n\r\n\r\nfunction App() {\r\n  // currentModel is what we're currently rendering.\r\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\r\n  const [currentModel, _setCurrentModel] = useState<IAnalyzedModel>(() => {\r\n    return loadTemplateModel()\r\n  });\r\n  const [maxPanels, setMaxPanels] = useState(1);\r\n\r\n  const setCurrentModel = (m: IAnalyzedModel) => {\r\n\r\n\r\n\r\n    console.log(\"setting onAllowDrop\")\r\n    m.model.setOnAllowDrop((dragNode, dropInfo) => {\r\n\r\n      let dropNode = dropInfo.node;\r\n\r\n\r\n      if (dropInfo.location === DockLocation.BOTTOM || dropInfo.location === DockLocation.TOP) {\r\n        console.log(\"blocking drop on bottom / top to avoid complications with setting width\");\r\n        return false;\r\n      } else if ((dropInfo.location === DockLocation.LEFT || dropInfo.location === DockLocation.RIGHT) && m.nrOfHorizontalTabsets >= MAXTABSETS) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n\r\n      /*       if (m.nrOfHorizontalTabsets >= MAXTABSETS) {\r\n              if (dropInfo.location === DockLocation.LEFT || dropInfo.location === DockLocation.RIGHT) {\r\n                return false;\r\n               if (dropNode.getType() === TabSetNode.TYPE) {\r\n                  // const p = dropNode.getParent();\r\n                  // if (p && p.getType() === RowNode.TYPE && p.getOrientation() === Orientation.HORZ && p.getChildren().length >= MAXTABSETS) {\r\n                  console.log(\"No\")\r\n                  return false;\r\n                  // }\r\n                } else if (dropNode.getType() === RowNode.TYPE && dropNode.getId() === m.model.getRoot().getId()) {\r\n                  console.log(\"NO\");\r\n                  return false;\r\n                }\r\n       \r\n      \r\n            }\r\n            return true;\r\n          } */\r\n\r\n    });\r\n    _setCurrentModel(m);\r\n  }\r\n\r\n  const factory = (node: TabNode) => {\r\n    var component = node.getComponent();\r\n    if (component === \"text\") {\r\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().uri }} />\r\n    } else if (component === \"pdf\") {\r\n      const iStyles = {\r\n        height: '99%',\r\n        width: '99%',\r\n        overflow: 'hidden',\r\n        border: 'none'\r\n      }\r\n      const cont = {\r\n        height: '100%',\r\n        width: '100%',\r\n        overflow: 'hidden'\r\n      }\r\n      return <div style={cont}>  <iframe src={node.getConfig().uri} className=\"invisible-scrollbar\" style={iStyles} scrolling=\"no\" /> </div>\r\n    } else if (component === \"image\") {\r\n      const s = {\r\n        height: '99%',\r\n        width: '99%'\r\n      }\r\n      return <img src={node.getConfig().uri} style={s} />\r\n    } else if (component === \"123check\") {\r\n      const s = {\r\n        width: '1200px',\r\n        height: '1000px'\r\n      }\r\n      return <img src={node.getConfig().uri} style={s} />\r\n    }\r\n  }\r\n\r\n  const interceptAction = (action: Action) => {\r\n\r\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\r\n    // this new tabset will not have a minimum size and so this needs to be set\r\n    // also for deletion of tabs or addition of nodes, the size may be impacted\r\n    // setTimeout(() => {\r\n    //   setCurrentModel(analyseModel(currentModel.model, true /* update min sizes if needed*/));\r\n    // }, 100);\r\n\r\n    return action;\r\n  }\r\n\r\n  const loadPanels = (event: any) => {\r\n    setMaxPanels(parseInt(event.target.value));\r\n    setCurrentModel(loadTemplateModel(parseInt(event.target.value)));\r\n  }\r\n\r\n\r\n\r\n  const modelChanged = (model: Model) => {\r\n    setCurrentModel(analyseModel(currentModel.model, false /* avoid infintie loop*/))\r\n  }\r\n\r\n  const add = () => {\r\n\r\n    if (MAXTABSETS > currentModel.nrOfHorizontalTabsets) {\r\n      addTabset(currentModel);\r\n    }\r\n\r\n  }\r\n\r\n  const equalise = () => {\r\n    equaliseWidth(currentModel);\r\n  }\r\n\r\n  const disabled = (MAXTABSETS <= currentModel.nrOfHorizontalTabsets);\r\n\r\n  return (\r\n    <div className=\"outer\">\r\n      <button onClick={add} disabled={disabled}>\r\n        Add Tabset\r\n      </button>\r\n      <button onClick={equalise} >\r\n        Equalize Width\r\n      </button>\r\n      <span>\r\n        &nbsp;&nbsp;&nbsp;Number of horizontal tabsets: {currentModel.nrOfHorizontalTabsets}&nbsp;&nbsp;&nbsp;&nbsp;\r\n      </span>\r\n      <span>\r\n        {(MAXTABSETS <= currentModel.nrOfHorizontalTabsets) ? \"MAXIMUM REACHED\" : \"\"}\r\n      </span>\r\n      <div className=\"inner\" >\r\n        {currentModel && (\r\n          <Layout\r\n            onAction={interceptAction}\r\n            onModelChange={modelChanged}\r\n            model={currentModel.model}\r\n            factory={factory} />)}\r\n      </div>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}