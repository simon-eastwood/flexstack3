{"version":3,"sources":["FlexModelUtils.ts","LoadTemplate.ts","App.tsx","index.tsx"],"names":["getConfig","tab","getType","TabNode","TYPE","Error","getId","max","dimension1","dimension2","result","Math","isNaN","setTabSetSize","tabset","updateIfNeeded","safeToSetWidth","minWidth","undefined","preferredWidth","width","getChildren","forEach","node","attrs","getMinWidth","currentWidth","getWidth","Object","keys","length","setSize","Actions","updateNodeAttributes","getModel","doAction","analyseRow","row","setWidth","tabsetChildren","filter","TabSetNode","getOrientation","Orientation","HORZ","ts","RowNode","childRowPreferredWidth","analyseRowTabs","nrOfTabSets","console","log","analyseModel","modelToAnalyse","alsoSetWidth","size","getRoot","tabs","model","nrOfTabsets","removeTabset","maxPanelNr","maxPanel","panels","Map","panelNr","visitNodes","set","childrenToMove","child","tabToDestination","dest","mv","p","get","destMajor","moveNode","DockLocation","CENTER","destMinor","destPref","del","deleteTabset","reorderTabs","tabsToMove","panelPreferences","floor","abs","round","bundleExample","w2wTemplateLayout","global","layout","isEmpty","c","getComponent","loadTemplateModel","fullModel","initialModel","Array","template","Model","fromJson","push","bundle","bundleItem","mfeConfig","mfe","getMfeConfig","type","destinationPanel","newConfig","name","title","component","config","panel","getTemplate","adaptedModel","nrPanels","rms","deleteTab","action","rmEmptyTabs","App","useState","currentModel","setCurrentModel","useEffect","setOnAllowDrop","dragNode","dropInfo","location","LEFT","RIGHT","disabled","className","onClick","m","a","addNode","n","getParent","rename","addTabset","doEqualise","onAction","onModelChange","onRenderTabSet","renderValues","buttons","factory","dangerouslySetInnerHTML","__html","uri","style","height","overflow","src","border","scrolling","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.10c6a147.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\nimport { mainModule } from 'process';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\ninterface IConfig {\r\n    width: number | undefined,\r\n    minWidth: number | undefined,\r\n    panelPreferences: number[],\r\n    preferredWidth: number | undefined,\r\n    nrOfHTabsets:number | undefined\r\n}\r\n\r\n\r\n// typesafe access to avoid typos in code\r\nconst getConfig = (tab: FLNode): IConfig => {\r\n    if (tab.getType() === TabNode.TYPE) {\r\n        return (tab as TabSetNode).getConfig() as IConfig;\r\n    } else {\r\n        throw Error(`Node ${tab.getId()} is not a tab and so does not have config`)\r\n    }\r\n}\r\n\r\n// return the max, taking into account that either or both might be undefined\r\nconst max = (dimension1: number | undefined, dimension2: number | undefined): number | undefined => {\r\n    let result = Math.max(dimension1!, dimension2!);\r\n    if (isNaN(result)) {\r\n        if (dimension1) return dimension1;\r\n        if (dimension2) return dimension2;\r\n        return undefined\r\n    } else {\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\nconst setTabSetSize = (tabset: TabSetNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): IDimensions => {\r\n    const result: IDimensions = {\r\n        minWidth: undefined,\r\n        preferredWidth: undefined,\r\n        width: undefined\r\n    };\r\n\r\n    // iterate through the tabs to get sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const tab = node as TabNode;\r\n\r\n        result.minWidth = max(result.minWidth, getConfig(tab)?.minWidth);\r\n        result.width = max(result.width, getConfig(tab)?.width);\r\n        result.preferredWidth = max(result.preferredWidth, getConfig(tab)?.preferredWidth);\r\n    })\r\n\r\n    if (!result.preferredWidth) {\r\n        if (result.width) {\r\n            result.preferredWidth = result.width;\r\n        } else {\r\n            result.preferredWidth = result.minWidth;\r\n        }\r\n    }\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if (updateIfNeeded) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n        type Attrs = {\r\n            minWidth?: number,\r\n            width?: number\r\n        };\r\n        const attrs: Attrs = {};\r\n        if (result.minWidth && result.minWidth > 0 && tabset.getMinWidth() !== result.minWidth) {\r\n            attrs.minWidth = result.minWidth;\r\n        }\r\n        const currentWidth = tabset.getWidth();\r\n        if (!safeToSetWidth && currentWidth) {\r\n            // Reset the width or there will be layout problems\r\n            attrs.width = 999999999;  // only way to clear an already-set width\r\n        } else if (!currentWidth && safeToSetWidth && result.width && currentWidth !== result.width) {\r\n            // if the current width is undefined (otherwise the user has set it and we'd better leave it alone)\r\n            // and it is safe to set the width (there are other tabsets to use free space)\r\n            // and there IS a width to set and its new\r\n            // only then: set the width\r\n            attrs.width = result.width;\r\n        }\r\n\r\n\r\n        // Now set the size information collated from the child tabs at the tabset level in the model\r\n        if (Object.keys(attrs).length > 0) {\r\n            const setSize = Actions.updateNodeAttributes(tabset.getId(), attrs);\r\n            tabset.getModel().doAction(setSize);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// returns preferred width (defaulting to the min width if there is no prefferd) of all tabsets in the row\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): number => {\r\n    let preferredWidth = 0;\r\n    let setWidth = false;\r\n\r\n    const tabsetChildren = row.getChildren().filter((node) => node.getType() === TabSetNode.TYPE);\r\n    if (tabsetChildren.length >= 2 && updateIfNeeded && row.getOrientation() === Orientation.HORZ) {\r\n        setWidth = true; // can only do this if there enough tabsets\r\n    }\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = setTabSetSize(node as TabSetNode, updateIfNeeded, setWidth);\r\n\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += ts.preferredWidth ? ts.preferredWidth : ts.minWidth!;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, ts.preferredWidth ? ts.preferredWidth : ts.minWidth)!;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const childRowPreferredWidth = analyseRow(node as RowNode, updateIfNeeded, setWidth);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += childRowPreferredWidth;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, childRowPreferredWidth)!;\r\n            }\r\n        }\r\n    })\r\n\r\n    return preferredWidth;\r\n}\r\n\r\n\r\nconst analyseRowTabs = (row: RowNode): number => {\r\n    let nrOfTabSets = 0;\r\n    console.log(\"analying row tabs\")\r\n    \r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            nrOfTabSets++;\r\n            \r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            //recurse\r\n            nrOfTabSets += analyseRowTabs (node as RowNode)\r\n        }\r\n    })\r\n\r\n    return nrOfTabSets;\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = true, alsoSetWidth: boolean = false): IAnalyzedModel => {\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(modelToAnalyse.getRoot(), updateIfNeeded, alsoSetWidth);\r\n\r\n    const tabs = analyseRowTabs (modelToAnalyse.getRoot());\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        preferredWidth: size,\r\n        nrOfTabsets: tabs\r\n    }\r\n\r\n    console.log(result);\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\n\r\n\r\n// 1. find the tabsets within the model and put them into a map based on their panel number\r\n// 2. for each panel, if its panel nr is larger than max panel then it needs to be deleted but not before...\r\n// 3. ...moving its children to their preferred destination specified in panelPreferences.\r\n// The child nodes are then moved to their new preferred / available panel\r\nexport const removeTabset = (model: Model, maxPanelNr?: number): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n\r\n    // first find out how many tabsets there are in the model and collect them in a map. \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n    maxPanel = (maxPanelNr) ? maxPanelNr : panels.size;\r\n\r\n    if (panels.size < 2) {\r\n        // don't want to delete the last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    // Now delete the top N tabsets\r\n    // if this function is called without a maxPanelNr then that's just the last panel (e.g. 5)\r\n    // if this function is called with a maxPanelNr (cos we're loading a template and the user only wants e.g. 2 panels) then that could be more than 1\r\n\r\n    panels.forEach((ts, panelNr) => {\r\n        if (panelNr >= maxPanel) {\r\n            // move the children\r\n            const childrenToMove = new Map<TabNode, Destination>();\r\n            ts.getChildren().forEach((child) => {\r\n                if (child.getType() === 'tab') {\r\n                    const tab = child as TabNode;\r\n                    childrenToMove.set(tab, tabToDestination(tab, maxPanel - 1));\r\n                }\r\n            })\r\n\r\n            childrenToMove.forEach((dest, child) => {\r\n                let p = panels.get(dest.destMajor);\r\n                let mv;\r\n                if (p) {\r\n                    mv = Actions.moveNode(child.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                } else {\r\n                    // got to move it somewhere....then to root\r\n                    mv = Actions.moveNode(child.getId(), model.getRoot().getId(), DockLocation.CENTER, - 1, false);\r\n                }\r\n                model.doAction(mv);\r\n            })\r\n\r\n\r\n            // delete the tabset. Actually an empty tabset will not be rendered\r\n            // but this will confuse the task of finding next tab to remove\r\n            // so better to clean up\r\n            let del = Actions.deleteTabset(ts.getId());\r\n            model.doAction(del);\r\n        }\r\n    })\r\n\r\n    // With less tabsets, some other tabs might prefer to be moved\r\n    reorderTabs(model);\r\n    return model;\r\n}\r\n\r\n// move tabs if necessary so that they are all on their preferred panel, in the preferred order\r\nconst reorderTabs = (model: Model) => {\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n    // first find out how many tabsets there are in the model \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n\r\n    // Now iterate through the tabs and see where to move them\r\n    const tabsToMove = new Map<TabNode, Destination>();\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tab') {\r\n            tabsToMove.set(node as TabNode, tabToDestination(node as TabNode, panels.size));\r\n        }\r\n    });\r\n\r\n\r\n    // now do the moves\r\n    tabsToMove.forEach((dest, tab) => {\r\n        let mv;\r\n\r\n        if (dest.destMajor !== 0) {\r\n            let p = panels.get(dest.destMajor);\r\n            // tabOrder is the number after the decimal point\r\n            if (p) {\r\n                mv = Actions.moveNode(tab.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                model.doAction(mv);\r\n            }\r\n        }\r\n\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n// use tab config to see, for the given max panel, where the tab should go\r\ntype Destination = {\r\n    destPref: number | undefined, // the original config value (can be negative or undefined)\r\n    destMajor: number, // 0 means unknown destination\r\n    destMinor: number\r\n}\r\nconst tabToDestination = (tab: TabNode, maxPanel: number = 4): Destination => {\r\n    let destPref;\r\n\r\n    if (getConfig(tab)?.panelPreferences?.length >= maxPanel) {\r\n        destPref = getConfig(tab).panelPreferences[maxPanel - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n\r\n        return {\r\n            destPref,\r\n            destMajor,\r\n            destMinor\r\n        }\r\n    } else {\r\n        return {\r\n            destPref,\r\n            destMajor: 0,\r\n            destMinor: -1\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nexport const addTabset = (m: IAnalyzedModel) => {\r\n\r\n\r\n     const a = Actions.addNode(  {type:\"tab\", component: \"pdf\", config:         {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"ML\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n        }},  m.model.getRoot().getId(), DockLocation.RIGHT, 0, true)\r\n\r\n    const n = m.model.doAction(a);\r\n    console.log(n);\r\n    if (n?.getParent()?.getType() === TabSetNode.TYPE) {\r\n        const rename = Actions.updateNodeAttributes(\"\" + n?.getParent()?.getId(), { config: { name: \"\" + (m.nrOfTabsets + 1) }});\r\n        m.model.doAction(rename);\r\n    }\r\n    \r\n\r\n}\r\n\r\nexport const equalise = (m: IAnalyzedModel) => {\r\n    console.log(\"Equalise\");\r\n    type Attrs = {\r\n            weight?: number,\r\n            width?: number\r\n    };\r\n    const attrs: Attrs = {};\r\n    attrs.width = 999999999; // only way to clear an already-set width\r\n    attrs.weight = 1;\r\n  \r\n    console.log (\"Root orientation is\" + m.model.getRoot().getOrientation() )\r\n    m.model.visitNodes(node => {\r\n        if (node.getType() === TabSetNode.TYPE || node.getType()  === RowNode.TYPE) {\r\n        \r\n                              const setSize = Actions.updateNodeAttributes(node.getId(), attrs);\r\n                    m.model.doAction(setSize);\r\n       \r\n        }\r\n    });\r\n\r\n}","import { Model, IJsonModel, TabSetNode, TabNode, Actions, Node as FLNode, Action } from 'flexlayout-react';\r\n\r\nimport { analyseModel, removeTabset } from './FlexModelUtils';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\nconst bundleExample = {\r\n    \"id\": \"igra\",\r\n    \"bundle\": [\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"Communication\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [1.1, 1.1, 1.1, 1.1, 1.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://ai.stanford.edu/~nilsson/MLBOOK.pdf#view=FitH\",\r\n            \"title\": \"Letter\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.3, -1.3, 2.1, 2.1, 2.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n            \"title\": \"Claims\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.4, -2.2, -3.2, 3.1, 3.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n            \"title\": \"Orig Claims\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.2, -1.2, -1.2, -1.2, 4.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"Machine Learning\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n        }\r\n\r\n    ]\r\n};\r\n\r\nconst w2wTemplateLayout: { name: string, model: IJsonModel } = {\r\n    name: 'w2w-template',\r\n    model: {\r\n        global: {\r\n            \"rootOrientationVertical\": false,\r\n            // \"tabSetEnableDivide\": false, // it keeps things simpler for moving tabs if all tabsets are labelled with a panel nr\r\n            // \"enableEdgeDock\": false, // otherwise the user can create new rows by dragging into the edge\r\n            //\"tabEnableClose\": false\r\n            \"tabSetClassNameHeader\": \"MyTabsetClass\"\r\n        }, // {tabSetEnableTabStrip:false}, // to have just splitters\r\n        layout: {\r\n            \"type\": \"row\",\r\n            \"children\": [\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"name\": \"1\"\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"name\": \"\",\r\n                            \"type\": \"tab\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"name\": \"2\"\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"name\": \"3\"\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"name\": \"4\"\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"name\": \"5\"\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": true,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n};\r\n\r\n\r\nconst getMfeConfig = (mfe: string): IDimensions => {\r\n    // hard coded for now....\r\n\r\n    switch (mfe) {\r\n        case 'pdf':\r\n            return {\r\n                minWidth: 50,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n        case '123check':\r\n            return {\r\n                minWidth: 774,\r\n                preferredWidth: 1280,\r\n                width: 1280\r\n            }\r\n\r\n            break;\r\n        case 'image':\r\n            return {\r\n                minWidth: 250,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n\r\n            break;\r\n        default:\r\n            return {\r\n                minWidth: undefined,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n    }\r\n}\r\n\r\n\r\nconst isEmpty = (tab: TabNode): boolean => {\r\n    const c = tab.getComponent();\r\n    const check = !c || c.length === 0;\r\n    return check;\r\n}\r\n\r\n\r\nconst getTemplate = (): Model => {\r\n    const panels = new Array<TabNode>();\r\n\r\n    const template = Model.fromJson(w2wTemplateLayout.model);\r\n\r\n    template.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            const tab = node as TabNode;\r\n            if (isEmpty(tab)) {\r\n                panels.push(tab);\r\n            }\r\n        }\r\n    });\r\n\r\n    bundleExample.bundle.forEach((bundleItem) => {\r\n        const destPref = bundleItem.panelPreferences[panels.length - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n        const mfeConfig = getMfeConfig(bundleItem.type);\r\n\r\n        let destinationPanel = panels[0]; // default\r\n        if (destMajor <= panels.length) {\r\n            destinationPanel = panels[destMajor - 1];\r\n        }\r\n\r\n        const newConfig = { ...destinationPanel.getConfig(), ...mfeConfig, ...bundleItem };\r\n\r\n        const attrs = {\r\n            name: bundleItem.title,\r\n            component: bundleItem.type,\r\n            config: newConfig\r\n        };\r\n        const set = Actions.updateNodeAttributes(destinationPanel.getId(), attrs);\r\n        template.doAction(set);\r\n    });\r\n\r\n    panels.forEach(panel => console.log(panel));\r\n\r\n    return template;\r\n}\r\n\r\n\r\nconst rmEmptyTabs = (model: Model) => {\r\n    const rms = new Array<Action>();\r\n    console.log(\"deleting\");\r\n    model.visitNodes(node => {\r\n        if (node.getType() === TabNode.TYPE && isEmpty(node as TabNode)) {\r\n            rms.push(Actions.deleteTab(node.getId()))\r\n        }\r\n    });\r\n    rms.forEach(action => model.doAction(action));\r\n}\r\n\r\n// if maxPanel is undefined, return the canonical model (or in future the user's saved model if there is one, and the canonical model failing that)\r\n// if maxPanel is defined, transform the model \r\nexport const loadTemplateModel = (maxPanel?: number) => {\r\n    let initialModel = getTemplate();\r\n    let adaptedModel = initialModel;\r\n    let fullModel: IAnalyzedModel;\r\n    console.log (\"loading model\")\r\n\r\n    // if the caller has specified the nr of panels, then return a model that meets that requirement\r\n    if (maxPanel) {\r\n        adaptedModel = removeTabset(initialModel, maxPanel + 1);\r\n\r\n        fullModel = analyseModel(adaptedModel, true, true);\r\n\r\n    } else { // I have to figure out myself how many panels fit the current viewport\r\n        // HACK for demo DFR const availableWidth = window.innerWidth;\r\n        const availableWidth = 200;\r\n\r\n\r\n        fullModel = analyseModel(initialModel, true, true);\r\n        // see how many panels there are in the full model\r\n        let nrPanels = 0;\r\n        fullModel.model.visitNodes((node) => { if (node.getType() === TabSetNode.TYPE) nrPanels++ });\r\n\r\n        // remove tabset one by one until it fits\r\n        while (nrPanels > 1 && availableWidth < fullModel.preferredWidth) {\r\n            adaptedModel = removeTabset(fullModel.model, nrPanels);\r\n            fullModel = analyseModel(adaptedModel, true, true);\r\n            nrPanels--;\r\n        }\r\n\r\n    }\r\n\r\n    // Now that all the processing has finished,\r\n    // delete any empty tabsets in case some panels were not used by the bundle\r\n    rmEmptyTabs(fullModel.model);\r\n\r\n\r\n    // removing empty tabs will not impact the dimensions, so no need to recalculate\r\n    return fullModel;\r\n\r\n}","import React, { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport 'flexlayout-react/style/light.css'\r\n\r\nimport { Layout, Model, TabNode, Action, DockLocation, TabSetNode, RowNode, Orientation, ITabSetRenderValues, BorderNode } from 'flexlayout-react';\r\n\r\nimport { addTabset, analyseModel, equalise as doEqualise } from './FlexModelUtils';\r\n\r\n\r\nimport { loadTemplateModel } from './LoadTemplate'\r\nimport { IAnalyzedModel } from './types';\r\n\r\nconst MAXTABSETS = 6;\r\n\r\n\r\nfunction App() {\r\n  // currentModel is what we're currently rendering.\r\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\r\n  const [currentModel, setCurrentModel] = useState<IAnalyzedModel>(() => {\r\n    return loadTemplateModel()\r\n  });\r\n\r\n  useEffect(() => {\r\n    currentModel.model.setOnAllowDrop((dragNode, dropInfo) => {\r\n /*      if (dropInfo.location === DockLocation.BOTTOM || dropInfo.location === DockLocation.TOP) {\r\n        // blocking drop on bottom / top to avoid complications with setting width for layouts with multi horz rows\r\n        return false;\r\n      } else */ if ((dropInfo.location === DockLocation.LEFT || dropInfo.location === DockLocation.RIGHT) && currentModel.nrOfTabsets >= MAXTABSETS) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n\r\n    });\r\n  }, [currentModel]);\r\n\r\n\r\n  const [maxPanels, setMaxPanels] = useState(1);\r\n\r\n\r\n\r\n  const factory = (node: TabNode) => {\r\n    var component = node.getComponent();\r\n    if (component === \"text\") {\r\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().uri }} />\r\n    } else if (component === \"pdf\") {\r\n      const iStyles = {\r\n        height: '99%',\r\n        width: '99%',\r\n        overflow: 'hidden',\r\n        border: 'none'\r\n      }\r\n      const cont = {\r\n        height: '100%',\r\n        width: '100%',\r\n        overflow: 'hidden'\r\n      }\r\n      return <div style={cont}>  <iframe src={node.getConfig().uri} className=\"invisible-scrollbar\" style={iStyles} scrolling=\"no\" /> </div>\r\n    } else if (component === \"image\") {\r\n      const s = {\r\n        height: '99%',\r\n        width: '99%'\r\n      }\r\n      return <img src={node.getConfig().uri} style={s} />\r\n    } else if (component === \"123check\") {\r\n      const s = {\r\n        width: '1200px',\r\n        height: '1000px'\r\n      }\r\n      return <img src={node.getConfig().uri} style={s} />\r\n    }\r\n  }\r\n\r\n  const interceptAction = (action: Action) => {\r\n\r\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\r\n    // this new tabset will not have a minimum size and so this needs to be set\r\n    // also for deletion of tabs or addition of nodes, the size may be impacted\r\n    // setTimeout(() => {\r\n    //   setCurrentModel(analyseModel(currentModel.model, true /* update min sizes if needed*/));\r\n    // }, 100);\r\n\r\n    return action;\r\n  }\r\n\r\n  const loadPanels = (event: any) => {\r\n    setMaxPanels(parseInt(event.target.value));\r\n    setCurrentModel(loadTemplateModel(parseInt(event.target.value)));\r\n  }\r\n\r\n\r\n\r\n  const modelChanged = (model: Model) => {\r\n    setCurrentModel(analyseModel(currentModel.model, false /* avoid infintie loop*/))\r\n  }\r\n\r\n  const add = () => {\r\n\r\n    if (MAXTABSETS > currentModel.nrOfTabsets) {\r\n      addTabset(currentModel);\r\n    }\r\n\r\n  }\r\n\r\n  const equalise = () => {\r\n    doEqualise(currentModel);\r\n  }\r\n\r\n  const disabled = (MAXTABSETS <= currentModel.nrOfTabsets);\r\n\r\n\r\n  const onRenderTabSet = (node: (TabSetNode | BorderNode), renderValues: ITabSetRenderValues) => {\r\n\r\n    const name = node.getConfig()?.name;\r\n\r\n    //renderValues.headerContent = \"-- \" + renderValues.headerContent + \" --\";\r\n    //renderValues.buttons.push(<img style={{width:\"1em\", height:\"1em\"}} src=\"images/folder.svg\"/>);\r\n    renderValues.buttons.push(\r\n      /*       <img src=\"images/add.svg\"\r\n              alt=\"Add\"\r\n              key=\"Add button\"\r\n              title=\"Add Tab (using onRenderTabSet callback, see Demo)\"\r\n              style={{ width: \"1.1em\", height: \"1.1em\" }}\r\n              className=\"flexlayout__tab_toolbar_button\"\r\n              onClick={() => console.log(node)}\r\n            /> */\r\n      <span>{name ? name : \"0\"}</span>\r\n    );\r\n\r\n  }\r\n\r\n  return (\r\n    <div className=\"outer\">\r\n      <button onClick={add} disabled={disabled}>\r\n        Add Tabset\r\n      </button>\r\n      <button onClick={equalise} >\r\n        Equalize\r\n      </button>\r\n      <span>\r\n        &nbsp;&nbsp;&nbsp;Number of tabsets: {currentModel.nrOfTabsets}&nbsp;&nbsp;&nbsp;&nbsp;\r\n      </span>\r\n      <span>\r\n        {(MAXTABSETS <= currentModel.nrOfTabsets) ? \"MAXIMUM REACHED\" : \"\"}\r\n      </span>\r\n      <div className=\"inner\" >\r\n        {currentModel && (\r\n          <Layout\r\n            onAction={interceptAction}\r\n            onModelChange={modelChanged}\r\n            onRenderTabSet={onRenderTabSet}\r\n            model={currentModel.model}\r\n            factory={factory} />)}\r\n      </div>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}